<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "http://xml.resource.org/authoring/rfc2629.dtd" [
<!ENTITY rfc3920 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3920.xml'>
<!ENTITY OWTP "Google Wave Federation Protocol">
<!ENTITY rncschema SYSTEM "waveschema.xml">
<!NOTATION rnc PUBLIC "RNC schema file">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<!--- This processing instruction ensures the formatters don't output text implying this is a real RFC, since we are just using this as a nice formatting for now -->
<?rfc private=" "?>
<rfc>
	<front>
		<title>Google Wave Federation Protocol Over XMPP</title>
		<author initials="J." surname="Bekmann" fullname="Jochen Bekmann">
			<organization>Google, Inc. </organization>
			<address>
				<email>jochen@google.com</email>
			</address>
		</author>
		<author initials="D." surname="Berlin" fullname="Daniel Berlin">
			<organization>Google, Inc. </organization>
			<address>
				<email>dannyb@google.com</email>
			</address>
		</author>
		<author initials="S." surname="Lassen" fullname="Soren Lassen">
			<organization>Google, Inc. </organization>
			<address>
				<email>soren@google.com</email>
			</address>
		</author>
		<author initials="S." surname="Thorogood" fullname="Sam Thorogood">
			<organization>Google, Inc. </organization>
			<address>
				<email>thorogood@google.com</email>
			</address>
		</author>
		<date year="2009" month="June"/>
		<note title="Document Status">
			<t>This document represents work in progress. It omits details that we are unable to capture at this 
			point and we expect parts of the protocol to change. Please also note that while we revise the 
			protocol and white papers, some transient inconsistencies will occur.
		</t>
		</note>
	</front>
	<middle>
		<section title="Introduction" anchor="intro">
			<section title="Overview" anchor="intro-overview">
				<t>The Google Wave Federation Protocol Over XMPP is an open extension to the <xref target="RFC3920">XMPP core</xref>
				 protocol allowing near real-time communication of wave updates between two wave servers.</t>
			</section>
			<section title="Terminology" anchor="intro-terms">
				<t>The capitalized key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="TERMS">BCP 14, RFC 2119</xref>.</t>
			</section>
		</section>
		<section title="Architectural Overview" anchor="arch">
			<t>Google Wave is a communication and collaboration platform based on hosted
        conversations, called waves. A wave consists of XML documents
        and supports concurrent modifications and low-latency updates between participants on the wave.</t>
			<section title="Wave Providers" anchor="providers">
				<t>The wave federation protocol enables everyone to become a wave
          provider and share waves with others. For instance, an organization
          can operate as a wave provider for its members, an individual can run
          a wave server as a wave provider for a single user or family members,
          and an Internet service provider can run a wave service as another
          Internet service for its users as a supplement to email, IM, ftp,
          etc.</t>
				<t>A wave provider is identified by its Internet domain name(s).</t>
				<t>Wave users have wave addresses which consist of a user name and a
          wave provider domain in the same form as an email address, namely
          &lt;username&gt;@&lt;domain&gt;. Wave addresses can also refer to groups, robots,
              gateways, and other services. A group address refers to a
              collection of wave addresses, much like an email mailing list. A
              robot can be a translation robot or a chess game robot. A gateway
              translates between waves and other communication and sharing
              protocols such as email and IM.  In the remainder we ignore
              addressees that are services, including robots and gateways - they
              are treated largely the same as users with respect to
              federation.</t>
				<t>Wave users access all waves through their wave provider. If a
              wave has participants from different wave providers, their wave
              providers all maintain a copy of the wave and serve it to their
              users on the wave. The wave providers share updates to the wave
              with each other using the wave federation protocol which we
              describe below.  For any given wave user, it is the responsibility
              of the wave provider for the user's domain to authenticate the
              user (using cookies and passwords, etc) and perform local access
              control.</t>
			</section><!--<t>More information on wave[let] and document identifiers, may be found in Alex North's identifier document. </t> -->
			<section title="Wavelets" anchor="wavelets">
				<t>A wave consists of a set of wavelets. When a user has access to a
          wavelet, that user is called a participant of that wavelet. Each
          wavelet has a list of participants, and a set of documents that make
          up its contents. Different wavelets of a wave can have different lists
          of participants. Copies of a wavelet are shared across all of the wave
          providers that have at least one participant in that wavelet. Amongst
          these wave providers, there is a designated wave provider that has the
          definitive copy of that wavelet. We say that this particular provider
          is hosting that wavelet.</t>
				<t>When a user opens a wave, a view of the wave is retrieved, namely the
          set of wavelets in the wave that the user is a participant of
          (directly, or indirectly via group membership). In general, different
          users have different wave views for a given wave. For example,
          per-user data for a user in a wave, such as the user's read/unread
          state for the wave, is stored in a user-data wavelet in the wave with
          the user as the only participant. The user-data wavelet only appears
          in this user's wave view. Another example is a private reply within a
          wave, which is represented as a wavelet with a restricted participant
          list. The private reply wavelet is only in the wave views of the
          restricted list of users.</t>
				<t>A wave is identified by a globally unique wave id, which is a pair of
          a domain name and an id string. The domain names the wave provider
          where the wave originated.</t>
				<t>A wavelet has a wavelet id which is unique within its wave. Like a
          wave id, a wavelet id is a pair of a domain name and an id string. The
          domain name in the wavelet id plays a special role: It names the wave
          provider that hosts the wavelet. A wavelet is hosted by the wave
          provider of the participant who creates the wavelet. The wave provider who hosts
          a wavelet is responsible both for operational transformation and application of 
          wavelet operations to the wavelet and for sharing the applied operations with 
          the wave providers of all the wavelet participants</t>
				<t>Wavelets in the same wave can be hosted by different wave providers.
          For example, a user-data wavelet is always hosted by the user's wave
          provider, regardless of where the rest of the wave is hosted. Indeed,
          user-data is not federated, i.e., not shared with other wave
          providers. Another example is a private reply wavelet. A particularly
          simple instance of this is when all the participants of the private
          reply are from the same wave provider. Then this wave provider will
          not share the private reply wavelet with other wave providers,
          regardless of where the other wavelets in the wave are hosted.</t>
			</section>
			<section title="Documents" anchor="documents">
				<t>Each wavelet is a container for any number of uniquely named
          documents. A document has an id that is unique within its containing
          wavelet and is composed of an XML document and a set of "stand-off"
          annotations. Stand-off annotations are pointers into the XML document
          and are independent of the XML document structure. They are used to
          represent text formatting, spelling suggestions and hyper-links.</t>
				<t>Some documents represent rich text messages in the wavelet. 
				These are known as "blips". The blips in a wave form a threaded 
				conversation. Others represent data, for example tags, and are 
				not displayed to the user as part of the threaded conversation 
				structure in the wave. For detailed information on the 
				structure of documents, please refer to the 
				<eref target="http://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/operational-transform">Google
            Wave Operational Transformation</eref> white paper.</t>
			</section>
			<section title="Operations" anchor="operations">
				<t>Operations are mutations on wavelets. The state of a wavelet is
          entirely defined by a sequence of operations on that wavelet.</t>
				<t>Clients and servers exchange operations in order to communicate
          modifications to a wavelet. Operations propagate through the system to
          all clients and servers interested in that wavelet. They each apply
          the operation to their own copy of the wavelet. The use of 
          <eref target="http://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/operational-transform">
          operational transformation (OT)</eref> guarantees all copies of the wavelet
          will eventually converge to the same state. In order for the
          guarantees made by OT to hold, all communication participants 
          must use the same operational transformation and composition algorithms
          (i.e. all OT implementations must be functionally equivalent).</t>
			</section>
			<section title="Wave Service Architecture" anchor="architecture">
				<t>A wave provider operates a wave service on one or more networked
          servers. The central pieces of the wave service is the wave store,
          which stores wavelet operations, and the wave server, which resolves
          wavelet operations by operational transformation and writes and reads
          wavelet operations to and from the wave store. Typically, the wave
          service serves waves to users of the wave provider which connect to
          the wave service frontend (see "Google Wave Data Model and
          Client-Server Protocol"), and we shall assume this in the following
          description of the wave service architecture. More importantly, for
          the purpose of federation, the wave service shares waves with
          participants from other providers by communicating with these wave
          provider's servers.</t>
				<t>For a given wave provider, its wave server serves wave views to local
          participants, i.e., participants from its domain. 
          This wave server stores the state of all wavelets that it knows about.
          Some are hosted by the wave server itself.  These are "local wavelets" relative to this wave server.
          Others are copies of wavelets hosted by other wave providers.  These are "remote".
          A wave view can contain both types of wavelet
          simultaneously.</t>
				<t>At a particular wave provider, local wavelets are those created at
          that provider, namely by users who belong to the wavelet provider. The
          wave server is responsible for processing the wavelet operations
          submitted to the wavelet by local participants and by remote
          participants from other wave providers. The wave server performs
          concurrency control by ordering the submitted wavelet operations
          relative to each other using operational transformation. It also
          validates the operations before applying them to a local wavelet.</t>
				<t>Remote wavelets are hosted by other wave providers. The wave server
          maintains cached copies locally and updates them with wavelet
          operations that it gets from the hosting wave providers. When a local
          participant submits a wavelet operation to a remote wavelet, the wave
          server forwards the operation to the wave server of the hosting
          provider. When the transformed and applied operation is echoed back,
          it is applied to the cached copy. Read access to local participants is
          done from the cached copy without a round trip to the hosting wave
          provider.</t>
				<t>Local and remote wavelets are all stored in the wave server's
          persistent wave store.</t>
				<t>We say that a wave provider is "upstream" relative to its local
          wavelets and that it is "downstream" relative to its remote
          wavelets.</t>
				<section title="Federation Host and Federation Remote" anchor="host-and-remote">
					<t>The wave service uses two components for peering with other wave providers, a
          "federation host" and a "federation remote". (In an earlier revision of this draft specification
          these components were called "federation gateway" and "federation proxy", respectively).</t>
					<t>The federation host communicates local wavelet operations, i.e.,
          operations on local wavelets:
          <list style="symbols">
							<t>It pushes new wavelet operations that are applied to a local
              wavelet to the wave providers of any remote participants.</t>
							<t>It satisfies requests for old wavelet operations.</t>
							<t>It processes wavelet operations submission requests.</t>
						</list>
					</t>
					<t>The federation remote communicates remote wavelet operations and is 
          the component of a wave provider that communicates with the federation 
          host of upstream wave providers:
          <list style="symbols">
							<t>It receives new wavelet operations pushed to it from the wave
              providers that host the wavelets.</t>
							<t>It requests old wavelet operations from the hosting wave
              providers.</t>
							<t>It submits wavelet operations to the hosting wave providers.</t>
						</list>
					</t>
					<t>An upstream wave provider's federation host connects to a
          downstream wave provider's federation remote to push wavelet operations
          that are hosted by the upstream wave provider.</t>
					<t>The federation protocol has the following mechanisms to make
          operation delivery from host to remote reliable. The federation
          host maintains (in persistent storage) a queue of outgoing
          operations for each remote domain. Operations are queued until their
          receipt is acknowledged by the receiving federation remote. The
          federation host will continually attempt to establish a connection
          and reconnect after any connection failures (retrying with an
          exponential backoff). When a connection is established, the federation
          host will send queued operations. The receiving federation
          remote sends acknowledgements back to the sending federation host 
          and whenever an acknowledgement is received, the sender
          dequeues the acknowledged operations.</t>
				</section>
			</section>
		</section>
		<section title="Protocol Specification">
			<section title="Connection Initiation and Lifetime">
				<t>As an XMPP extension, this protocol expects a bidirectional stream to
				 be established according to the XMPP core specification.</t>
				<t>The connection MUST be secured using the TLS feature of XMPP.
				It is RECOMMENDED that communication is encrypted (namely by using a non-identity TLS cipher).</t>
				<t>There are two kinds of XMPP streams shared between a federation host and a federation remote: 
				an <xref target="iq-elements-update-stream">update stream</xref> and a 
				<xref target="iq-elements-service-stream">service stream</xref>. Both may be initiated on demand
				(i.e. whenever needed) and are independent of each other.				
				</t>
				<t>All communication is made using IQ based stanzas, the stanzas of type "get" and "set" contain a unique 'id' attribute,
				 they are sent from the initiator to the receiver. The receiver MUST eventually reply to each "get" or "set" stanza with
				 a stanza of type "result" or "error" and the corresponding 'id' attribute.
				 The sender MUST NOT resend the "get" or "set" stanza for the duration of the XMPP connection. In the absence of a
				 reply, the sender SHOULD timeout and tear down the XMPP connection, then reconnect and retry. (The exact specification
				 of timeout duration, error stanzas and behaviour on receipt of errors is not yet specified).				
				</t>
			</section>
			<section title="Cryptographic Certificates and Signatures" anchor="security-note">
				<t>In the section below there are references to cryptographic signatures and certificates used to generate them.</t>
				<t>The paper by Kissner and Laurie, 
	            <eref target="https://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/wave-protocol-verification">General Verifiable Federation</eref>
	            gives a detailed explanation of how we expect to make all changes to wavelets attributable to their originating servers
	            and render the federation protocol immune to a number of attacks. The techniques described in the paper have not yet been fully
	            implemented or incorporated into this protocol specification, these will be complemented with a certificate management and exchange
	            protocol.</t>
			</section>
			<section title="IQ Based Stanzas" anchor="iq-stanzas">
				<t>The federation protocol involves two parties: a wave federation host and wave
        federation remote as described <xref target="host-and-remote">above</xref>. The
        top level IQ stanzas are devided into two types: those that are part of the "update stream", and those part of the "service stream".
        The <xref target="iq-elements-update-stream">update stream</xref> is initiated by a federation host to a federation remote and carries 
        <xref target="elements-update">&lt;update/&gt;</xref>s from the host to the remote. 
        The <xref target="iq-elements-service-stream">service stream</xref> is initiated by the federation remote to the federation host and
        carries <xref target="elements-submit-request">&lt;submit-request/&gt;</xref>s and 
        <xref target="elements-submit-response">&lt;submit-response/&gt;</xref>s, as well as 
        <xref target="elements-history-request">&lt;history-request/&gt;</xref>s and 
        <xref target="elements-history-response">&lt;history-response/&gt;</xref>s.</t>
				<section title="Commonly used attributes" anchor="attributes">
					<t>These IQ stanzas commonly contain the following attributes:</t>
					<section title="address" anchor="wave-address">
						<t>A wave address is identified by a string formatted as an email
            address (RFC 2822). </t>
					</section>
					<section title="wavelet-name" anchor="elements-wavelet-name">
						<t>The 'wavelet-name' attribute is an encoded form of the following components:</t>
						<t>
							<list style="symbols">
								<t>A "wave id" specifies the domain of the wave provider that originally started the wave, plus
								an identifier unique within that domain.</t>
								<t>A "wavelet id" specifies the domain of the wave provider that hosts the wavelet, plus
								 a unique identifier which is unique within all wavelets with that domain, within the wave.</t>
							</list>
						</t>
						<t>These components are encoded into a single string in the format of a netpath of an URI. The wavelet id domain 
							  is used as the host part (since this is 
   							where the wavelet is hosted). The wave id is used as the first path element, which contains the wave id domain
   							if it does not match the wavelet id domain, in this case it is prepended to a unique
   							identifier with a '$' delimiter. The unique identifier in the wavelet id is the final path element. 
   							URI generic delimiter 
   							characters (:/?#[]@) appearing in the id parts must be percent-escaped.</t>
						<t>For example, a 'wavelet-name' might be "initech-corp.com/acmewave.com$w+4Kl2/conv+3sG7", 
						where the wavelet id has domain "initech-corp.com" and unique identifier "conv+3sG7", 
						and the wave id has domain "acmewave.com" and unique identifier "w+4Kl2".</t>
						<t>If the wavelet was hosted at "initech-corp.com" and the wave had also been started on that domain, 
						the 'wavelet-name' would be "initech-corp.com/w+4Kl2/conv+3sG7".</t>
					</section>
				</section>
				<section title="Commonly used elements" anchor="elements">
					<section title="hashed-version" anchor="elements-history-hash">
						<t>A &lt;hashed-version/&gt; element contains the version and history hash pair of a wavelet. 
							<list style="symbols">
								<t>'version' -- REQUIRED attribute which contains the version of the wavelet.</t>
								<t>'history-hash' -- REQUIRED attribute which is the value of the rolling history hash at the given version.</t>
							</list>
						</t>
					</section>
					<section title="commit-notice" anchor="elements-commit-notice">
						<t>The &lt;commit-notice/&gt; element is a variant of the &lt;hashed-version/&gt; element. 
						It is used to indicate that the wave server has committed deltas up to this point.
							<list style="symbols">
								<t>'version' -- REQUIRED attribute which contains the version of the wavelet.</t>
								<t>'history-hash' -- REQUIRED attribute which is the value of the rolling history hash at the given version.</t>
							</list>
						</t>
					</section>
					<section title="delta" anchor="elements-delta">
						<t>The &lt;delta/&gt; element contains a sequence of one or more operations grouped for communication to and between wave servers:
							<list style="symbols">
								<t>'author' -- REQUIRED <xref target="wave-address">wave-address</xref> attribute of the contributor. Must be a wavelet participant.</t>
								<t>&lt;hashed-version/&gt; -- REQUIRED element version and history hash that this delta was intended to be applied to (pre-OT).</t>
								<t>&lt;operation/&gt; -- REQUIRED ONE OR MORE <xref target="wavelet-ops">operation</xref> elements.</t>
							</list>
						</t>
					</section>
					<section title="applied-delta" anchor="elements-applied-delta">
						<t>The &lt;applied-delta/&gt; element contains a delta which has been successfully applied to a wavelet by a wave server, along with 
						supplementary information about the result of the application.
							<list style="symbols">
								<t>'operations-applied' -- REQUIRED attribute with the number of operations applied by the wave server after transforming the submitted delta.</t>
								<t>'application-timestamp' -- REQUIRED timestamp (milliseconds since epoch) attribute recording the time of delta application.</t>
								<t>&lt;delta/&gt; -- REQUIRED <xref target="elements-delta">delta</xref> element.</t>
								<t>&lt;signature/&gt; -- REQUIRED <xref target="elements-signature">signature</xref> element. It signs the delta with the certificate
								of the delta's author's domain.</t>
								<t>&lt;hashed-version/&gt; -- REQUIRED element containing the history hash and version of the wavelet after the delta was applied.</t>
							</list>
						</t>
					</section>
					<section title="signature" anchor="elements-signature">
						<t>The &lt;signature/&gt; element is used to sign a delta with the author's domain's certificate. This signature is used by downstream wave providers to verify
						that the author's wave provider was in fact the source of the delta.
						</t>
						<t>The  &lt;signature/&gt; element includes a reference to the certificate used for the signing, the cryptographic signature and possibly a timestamp. 
						As noted in the <xref target="security-note">Cryptographic Certificates and Signatures</xref> section, the details have not yet
						been fully determined.		
					</t>
					</section>
				</section>
				<section title="Update Stream" anchor="iq-elements-update-stream">
					<t>The update stream sends and acknowledges updates.</t>
					<section title="update" anchor="elements-update">
						<t>The  &lt;update/&gt; element is used within an IQ stanza of type "set", and a unique 'id' attribute. 
						It is used to push new wavelet 
						operations applied to a local wavelet to the wave providers of any remote participants.
						The federation remote responds with an empty IQ stanza of type "result" with the matching 'id' attribute to 
						acknowledge the update.</t>
						<t>
							<list style="symbols">
								<t>&lt;wavelet-update/&gt; -- the update MUST contain ONE OR MORE &lt;wavelet-update/&gt; elements. The 
								syntax for a &lt;wavelet-update/&gt; is the following: 
		  					<list style="symbols">
										<t>'wavelet-name' -- REQUIRED wavelet name attribute.</t>
										<t>&lt;applied-delta/&gt; -- the update MAY contain ZERO OR MORE &lt;applied-delta/&gt; elements.</t>
										<t>&lt;commit-notice/&gt; -- OPTIONAL element informing the downstream wave server that the upstream wavelet 
									server has committed the wavelet operations up to the specified version to persistent storage.
										</t>
									</list>
								</t>
							</list>
						</t>
						<t>When the requester is resending updates after reconnecting a XMPP stream, 
						the &lt;update/&gt; MAY omit the &lt;applied-delta/&gt; elements but MUST resend the 
						&lt;commit-notice/&gt; elements. In this case the &lt;commit-notice/&gt; informs the receiver of the existence 
						of updates, and it is
						up to the receiver to request these using a &lt;history-request/&gt; on a service stream.</t>
					</section>
					<section title="Successful update and response example">
						<t>An example of otherwave.com's federation host pushing data to a federation remote:</t>
						<figure>
							<preamble>Step 1: otherwave.com's federation host sends an update to the federation remote:</preamble>
							<artwork><![CDATA[
<iq id='19' type='set'>
    <update>
      <wavelet-update wavelet-name='otherwave.com/acmewave.com$w+35mn/conv+897xvc'>  
         <applied-delta operations-applied=2 application-timestamp=897234>
           <hashed-version version=123 history-hash='234bcbde'/>
           <delta author='bob@acmewave.com'>
             <hashed-version version=120 history-hash='1e2acc34bc'/>
             <operation> .... </operation>
             <operation> .... </operation>
           </delta>
           <signature>...</signature>
         </applied-delta>
         <commit-notice version=125 history-hash='234feb234ba'/>
      </wavelet-update>
    </update>
</iq>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: The federation remote acknowledges the update, indicating success.</preamble>
							<artwork><![CDATA[
<iq id='19' type='result'/>
]]></artwork>
						</figure>
					</section>
				</section>
				<section title="Service Stream" anchor="iq-elements-service-stream">
					<t>The service stream sends requests and responses for the submission of operations and wavelet history retrieval.</t>
					<section title="history-request" anchor="elements-history-request">
						<t>The &lt;history-request/&gt; element is used within an IQ stanza of type "get". It is sent by a federation 
						remote to request wavelet operations from the hosting wave
            providers. The response by the host provider's federation host will contain the operations
            for the requested version range.
            													<list style="symbols">
								<t>'wavelet-name' -- REQUIRED attribute.</t>
								<t>'start-version' -- REQUIRED attribute with version number (inclusive) from which to retrieve the wavelet's history. (Note that 
the start version MUST fall on a delta boundary).</t>
								<t>'end-version' -- OPTIONAL attribute with ending version number (exclusive) up to which to retrieve the wavelet's history. (Note that 
the end version MUST fall on a delta boundary).</t>
								<t>'response-length-limit' -- OPTIONAL attribute containing advice from the requester about the preferred
  response limit, measured as the aggregate number of characters in the XML
  serialisation of the applied deltas in the response.  The responder is
  advised but not required to respect the limit.  Moreover, the responder
  may operate with a lower limit of its own and send back a smaller message
  than requested.  When the responder exercises either its own or the
  requesters limit, it will return only a prefix of the requested wavelet deltas.
  Unless the version range is empty, the responder will always return a minimum of
  one wavelet delta (the first) even if its length exceeds the responders or
  requester's limits.</t>
							</list>
						</t>
					</section>
					<section title="history-response" anchor="elements-history-response">
						<t>The &lt;history-response/&gt; element is used within an IQ stanza of type "result". 
						It satisfies requests for wavelet operations in response to a &lt;history-request/&gt; from a federation remote.
		  					<list style="symbols">
								<t>'version-truncated-at' -- OPTIONAL attribute indicating that the returned deltas were truncated at the given 
version number (exclusive).  Truncation will occur if the 
<xref target="elements-history-request">&lt;history-request/&gt;</xref> specified a 'response-length-limit' attribute or the responder imposed its own limit.</t>
								<t>&lt;applied-delta/&gt; -- the update contains ZERO OR MORE &lt;applied-delta/&gt; elements, starting from the requested version up to 
the requested end version (exclusive), or until the latest version if the request did not contain the end version, or up to the version
indicated in 'version-truncated-at'.</t>
								<t>&lt;commit-notice/&gt; -- OPTIONAL element indicating that some range of the returned deltas has not been
								 commited to persistent storage by the hosting wave server. The &lt;commit-notice/&gt; indicates up to which 
								 version the server has committed.</t>
							</list>
						</t>
					</section>
					<section title="Successful history request / history response example">
						<figure>
							<preamble>Step 1: A federation remote makes a
							<xref target="elements-history-request">history-request</xref> to the foobar.com federation host:</preamble>
							<artwork><![CDATA[
<iq id='239' type='get'>
    <history-request start-version=123 response-length-limit=100 
        wavelet-name='foobar.com/acmewave.com$xc867/nbm345'/>
</iq>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: foobar.com's federation host returns the requested history.</preamble>
							<artwork><![CDATA[
<iq id='239' type='result'>
  <history-response>
    <applied-delta operations-applied=2 application-timestamp=897234>
      <hashed-version version=123 history-hash='234bcbde'/>
      <delta author='bob@acmewave.com'>
        <hashed-version version=120 history-hash='2acc34bc'/>
        <operation> .... </operation>
        <operation> .... </operation>
      </delta>
      <signature>...</signature>        
    </applied-delta>
  </history-response>
</iq>
]]></artwork>
						</figure>
					</section>
					<section title="submit-request" anchor="elements-submit-request">
						<t>The &lt;submit-request/&gt; element is used within an IQ stanza of type "set".
						The federation remote submits wavelet operations to the hosting wave provider.
            A &lt;submit-response/&gt; will be returned.
	            <list style="symbols">
								<t>'wavelet-name' -- REQUIRED wavelet name attribute.</t>
								<t>&lt;delta/&gt; -- REQUIRED delta element to be submitted.</t>
								<t>&lt;signature/&gt; -- REQUIRED signature element as signed by the originator of the delta.</t>
								<t>&lt;address-access-path/&gt; -- OPTIONAL ONE OR MORE elements describing a path through the  
								<eref target="http://www.waveprotocol.org/whitepapers/access-control">address access control graph</eref>.</t>
							</list>
						</t>
					</section>
					<section title="submit-response" anchor="elements-submit-response">
						<t>A &lt;submit-response/&gt;  element is used within an IQ stanza of type "result". It is returned by a federation host 
						after the hosting wave server has processed the submitted delta.
						<list style="symbols">
								<t>'operations-applied' -- REQUIRED attribute with the number of operations applied by the wave server after transforming the submitted delta.</t>
								<t>'application-timestamp' -- REQUIRED timestamp (milliseconds since epoch) attribute recording the time of delta application.</t>
								<t>'error-message' -- OPTIONAL string attribute containing an error message if the an error occurred while applying the delta. 
								Note it's possible to partially apply a delta, in which case the error message will be present.</t>
								<t>&lt;hashed-version/&gt; -- REQUIRED element with the version and history hash of the wavelet after the submitted delta was applied.</t>
							</list>
						</t>
					</section>
					<section title="Successful submit request / submit response example">
						<figure>
							<preamble>Step 1: The federation remote makes an submit request to the foowave.com federation host:</preamble>
							<artwork><![CDATA[
<iq id='54312' type='set'>
    <submit-request wavelet-name='foowave.com/acmewave.com$345345/fsda'>
      <delta author='primates@acmewave.com'>
             <hashed-version version=100 history-hash='938bc36'/>
             <operation> .... </operation>
             <operation> .... </operation>
      </delta>
      <signature>...</signature>
      <address-path>
        <address>crazymonkey@otherwave.com</address>
      </address-path>
    </submit-request>
</iq>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: The foowave.com federation host returns a response to the submit request. Note that this example
							shows the case where a different party submitted a delta at version 100 with 3 operations before this submit-request was received.
							The requester's submitted delta was thus transformed before it was applied, and as a result the version number at which it was applied was 103.</preamble>
							<artwork><![CDATA[
<iq id='54312' type='result'>
    <submit-response operations-applied=2 application-timestamp=2794824789>
      <hashed-version version=105 history-hash='024bcbd879'/>
    </submit-response>
</iq>
]]></artwork>
						</figure>
					</section>
				</section>
			</section>
		</section>
		<section title="Wavelet Operations" anchor="wavelet-ops">
			<t>Wavelet operations mutate wavelets. The top level element for any wavelet operation is an &lt;operation/&gt; element. 
						</t>
			<t>The &lt;operation/&gt; element is simply a container element, and MUST contain exactly ONE of the four elements
			&lt;noop/&gt;, &lt;add-participant/&gt;, &lt;remove-participant/&gt;, and &lt;mutate-document/&gt;, which are specified below.
						The current implementation has the following three further operations &lt;submit-document/&gt;, &lt;add-document/&gt;,
						&lt;tombstone-document/&gt; that are deprecated and are
						omitted from this document because they are expected to be eliminated before this document is finalized.
						</t>
			<section title="noop" anchor="noop-element">
				<t>The &lt;noop/&gt; element is used to indicate a blank operation. It has no attributes and no child elements.</t>
			</section>
			<section title="add-participant" anchor="add-participant-element">
				<t>The &lt;add-participant/&gt; element is used to add a participant to a wave.  It has one attribute, the REQUIRED 'address' attribute,
				 which specifies the <xref target="wave-address">wave address</xref> of the participant.</t>
			</section>
			<section title="remove-participant" anchor="remove-participant-element">
				<t>The &lt;remove-participant/&gt; element is used to removed a participant from a wave.  It has one attribute, the REQUIRED 
				'address' attribute, which specifies the <xref target="wave-address">wave address</xref> of the participant.</t>
			</section>
			<section title="mutate-document" anchor="mutate-document-element">
				<t>The &lt;mutate-document/&gt; element is used to specify a modification of a document's content. It MUST contain a 'document-id'
				attribute, and ONE OR MORE <eref target="mutation-children">document mutation elements.</eref>
				</t>
				<section title="Document mutation semantics" anchor="mutation-semantics">
					<t>Content mutations for a document operation operate on a XML document with "stand-off" annotations. The mutations maintain
					 a current operation point, also referred to as the 'cursor'. Much like the cursor in a text editor, this specifies 
					where the next operation in the stream should be applied. The cursor begins at position zero. &lt;skip/&gt; operations
					 are used to explicitly modify the current operation point, and the remainder of the operations are used to modify the 
					 actual textual content of the document. However these other operations may also implicitly affect the location of the 
					 current operation point.</t>
					<t>Note that the cursor treats every start-tag and end-tag within the XML as having a character length of one. For example, 
					if a cursor is located before the start-tag &lt;blip&gt; and is moved forward by one, it will now be located immediately after 
					this start-tag &lt;blip&gt;.</t>
					<t>Internally, XML documents within a wave MUST NOT contain the empty-element tag, i.e., a merged start and end tag. That is, the 
					tag &lt;foo /&gt; is disallowed, and MUST be stored as &lt;foo&gt;&lt;/foo&gt;. This is even the case for tags which would 
					normally be represented as an empty-element, such as &lt;br /&gt;.</t>
					<t>It should be understood that this encoding is in no way assumed to be the most efficient way to encode XML documents as a 
					set of operations.  However, the document operations specified below are easily 
					composable and transformable, which is a requirement for concurrency control transforms.  They are also used to accurately 
					represent the history of the document for playback.</t>
				</section>
				<section title="Document mutation elements" anchor="mutation-children">
					<t>The &lt;skip/&gt; element is used to specify portions of the document that are not modified by the content mutation.  It has one REQUIRED attribute, 'size', which specifies the number of characters since the last mutation operation to skip before applying the next mutation operation. As a result, this element is used to modify the current operation point for the next content mutation operation.</t>
					<t>The &lt;characters/&gt; element is used to specify text additions to the document.  It has one REQUIRED attribute, 'characters', which specifies the characters to be added to the document at the current insertion point. After this operation, the cursor will be located after the inserted characters.</t>
					<t>The &lt;element-start/&gt; element is used to specify the beginning of a tagged element in the document.  It has one REQUIRED attribute, 'name', which specifies the tag name of the element to be added to the document at the current insertion point.  The &lt;element-start/&gt; element can OPTIONALLY have any number of children used to specify attributes for this element.  These children are &lt;attribute/&gt; elements, which have two REQUIRED attributes, 'name' and 'value', specifying the name and value of the attribute for the element, respectively. After this operation, the cursor will move forward one step, i.e., after the newly inserted start-tag.</t>
					<t>The &lt;element-end/&gt; element is used to specify the end of a tagged element.  It is REQUIRED that every &lt;element-start/&gt; element have a matching &lt;element-end/&gt; element. After this operation, the cursor will move forward one step, i.e., after the newly inserted end-tag.</t>
					<t>The &lt;anti-element-start/&gt; element is used to specify the beginning of a "split" element in the document. It takes NO attributes. Functionally, it will insert an end-tag element which matches with the nearest start-tag to the left of the cursor. It will also move the cursor one position forward, after this inserted end-tag.</t>
					<t>The &lt;anti-element-end/&gt; element is used to specify the end of a split element in the document. The &lt;anti-element-end/&gt; can OPTIONALLY have any number of children used to specify attributes for this element. These children are &lt;attribute/&gt; elements, which have two REQUIRED attributes, 'name' and 'value', specifying the name and value of the attribute for the element, respectively. After this operation, the cursor will move forward one step, i.e., after the newly inserted start-tag. This element MUST be paired with a &lt;anti-element-start/&gt; element.</t>
					<t>The &lt;delete-characters/&gt; element is used to specify text deletions from the document.  It has one REQUIRED attribute, 'size', which specifies the number of characters to be deleted from the document.  This operation deletes characters AFTER this cursor, and does not modify the cursor location. All deletion operations will, of course, immediately reduce the total length of the document.</t>
					<t>The &lt;delete-element-start/&gt; indicates the deletion of the start-tag directly under the cursor. i.e., the position directly after the cursor. It MUST be paired with a later &lt;delete-anti-element-end/&gt;. This pairing - on its own - MUST NOT delete the textual content between these two points. The cursor does not move as a result of this operation. Again, this operation will reduce the total length of the document. A notable side effect of this is that deleting a matching start-tag and end-tag, which are next to each other, requires two delete operations and NO cursor moves.</t>
					<t>The &lt;delete-element-end/&gt; indicates the deletion of the end-tag directly under the cursor. It MUST be paired with a previous &lt;delete-element-start/&gt;. The cursor does not move as a result of this operation.</t>
					<t>The &lt;delete-anti-element-start/&gt; indicates the deletion of the end-tag directly under the cursor. It MUST be paired with a later &lt;delete-anti-element-end/&gt; containing the same tag, at the same tree level within the XML document. The cursor does not move as a result of this operation.</t>
					<t>The &lt;delete-anti-element-end/&gt; indicates the deletion of an start-tag directly under the cursor. It MUST be paired with a previous &lt;delete-anti-element-start/&gt; element containing the same tag. The cursor does not move as a result of this operation.</t>
					<t>The &lt;set-attributes/&gt; element is used to set XML attributes on the start-tag (e.g. &lt;blip&gt;) directly under the cursor. It first MUST clear all previous attributes on this start-tag. It then MUST iterate through the OPTIONAL set of child &lt;attribute/&gt; elements and apply their key/value pairs as attributes to the start-tag.</t>
					<t>The &lt;update-attributes/&gt; element is used in the same way as &lt;set-attributes/&gt;, except that it does not first clear attributes, and only updates the attributes on the start-tag. Note that if the 'value' attribute of an &lt;attribute/&gt; is NOT set, then this indicates the deletion of the named attribute.</t>
					<t>The &lt;start-annotation/&gt; begins the mark-up of a ranged annotation, an extension to XML used within the Google Wave Federation Protocol. This annotation is uniquely identifed by a key and may span across normal XML tag boundaries. It has one REQUIRED attribute, 'key', and one OPTIONAL attribute, 'value'. If the value is NOT set, then this denotes the deletion of a ranged annotation.</t>
					<t>The &lt;end-annotation/&gt; denotes the end of a ranged annotation, and contains a single attribute of 'key'. This pairs the end of this annotation with the previous &lt;start-annotation/&gt;</t>
				</section>
			</section><!--			
			<section title="Currently used operations, but to be deprecated:">
				<t>The following operations are currently used, and we expect will be supported in the first iteration of our protocol,
			however they will be deprecated soon after.</t>
				<section title="add-document" anchor="add-document-element">
					<t>The &lt;add-document/&gt; element is used to append a <xref target="documents">document</xref> to a wavelet.  It has three attributes:</t>
					<t>
						<list style="symbols">
							<t>'document-id' - - REQUIRED attribute specifying a wavelet-wide unique id for the document being created</t>
							<t>'parent-id' - - OPTIONAL attribute, which specifies a document id for the parent of this document, if there is one. Having no parent id implies this document is the root of a conversation.</t>
							<t>The receiving entity MUST verify the parent id of a document is valid if the 'parent-id' attribute is specified.</t>
						</list>
					</t>
				</section>
				<section title="tombstone-document" anchor="tombstone-document-element">
					<t>The &lt;tombstonedocument&gt; element is used to mark a
	        single <xref target="documents">document</xref> as either
	        deleted or active. ALL documents, immediately after they are
	        created, are marked as active. This element has two attributes:</t>
					<t>
						<list style="symbols">
							<t>'document-id' - - REQUIRED attribute which specifies the
	          <xref target="documents">document</xref> which is to be marked</t>
							<t>'istombstone' - - REQUIRED attribute which MUST take either
	          the value 'true', indicating that this document is to be be marked
	          as deleted, or 'false', which indicates that this document is to
	          be marked as active.</t>
						</list>
					</t>
				</section>
				<section title="submit-document" anchor="submit-document-element">
					<t>The &lt;submit-document/&gt; element is used to signal that a
	        document was submitted by the user. The main use of the submit document element is to mark points in the operation stream where playback should stop.</t>
				</section>
			</section>
-->
		</section>
	</middle>
	<back>
		<references title="References">
			<reference anchor="TERMS">
				<front>
					<title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization>Harvard University</organization>
						<address>
							<postal>
								<street>1350 Mass.  Ave.</street>
								<street>Cambridge</street>
								<street>MA 02138</street>
							</postal>
							<phone>- +1 617 495 3864</phone>
							<email>sob@harvard.edu</email>
						</address>
					</author>
					<date month="March" year="1997"/>
					<area>General</area>
					<keyword>keyword</keyword>
					<abstract>
						<t>
					   In many standards track documents several words are used to signify
					   the requirements in the specification.  These words are often
					   capitalized.  This document defines these words as they should be
					   interpreted in IETF documents.  Authors who follow these guidelines
					   should incorporate this phrase near the beginning of their document:

							<list>
								<t>
						      The key words &quot;""""""""""MUST&quot;"""""""""", &quot;""""""""""MUST NOT&quot;"""""""""", &quot;""""""""""REQUIRED&quot;"""""""""", &quot;""""""""""SHALL&quot;"""""""""", &quot;""""""""""SHALL
						      NOT&quot;"""""""""", &quot;""""""""""SHOULD&quot;"""""""""", &quot;""""""""""SHOULD NOT&quot;"""""""""", &quot;""""""""""RECOMMENDED&quot;"""""""""",  &quot;""""""""""MAY&quot;"""""""""", and
						      &quot;""""""""""OPTIONAL&quot;"""""""""" in this document are to be interpreted as described in
						      RFC 2119.
								</t>
							</list>
						</t>
						<t>
						   Note that the force of these words is modified by the requirement
						   level of the document in which they are used.
						</t>
					</abstract>
				</front>
				<seriesInfo name="BCP" value="14"/>
				<seriesInfo name="RFC" value="2119"/>
				<format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
				<format type="HTML" octets="14486" target="http://xml.resource.org/public/rfc/html/rfc2119.html"/>
				<format type="XML" octets="5661" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"/>
			</reference>&rfc3920;
		</references>
		<section title="Protocol Schema">
			<t>The protocol schema, as RelaxNG compact:</t>
			<figure>
				<artwork>&rncschema;</artwork>
			</figure>
		</section>
	</back>
</rfc>
