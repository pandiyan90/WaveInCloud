<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "http://xml.resource.org/authoring/rfc2629.dtd" [
<!ENTITY rfc3920 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3920.xml'>
<!ENTITY OWTP "Google Wave Federation Protocol">
<!ENTITY rncschema SYSTEM "waveschema.xml">
<!ENTITY waveproto SYSTEM "waveproto.xml">
<!NOTATION rnc PUBLIC "RNC schema file">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<!--- This processing instruction ensures the formatters don't output text implying this is a real RFC, since we are just using this as a nice formatting for now -->
<?rfc private=" "?>
<rfc>
	<front>
		<title>Google Wave Federation Protocol Over XMPP</title>
		<author initials="A." surname="Baxter" fullname="Anthony Baxter">
			<organization>Google, Inc. </organization>
			<address>
				<email>arb@google.com</email>
			</address>
		</author>
		<author initials="J." surname="Bekmann" fullname="Jochen Bekmann">
			<organization>Google, Inc. </organization>
			<address>
				<email>jochen@google.com</email>
			</address>
		</author>
		<author initials="D." surname="Berlin" fullname="Daniel Berlin">
			<organization>Google, Inc. </organization>
			<address>
				<email>dannyb@google.com</email>
			</address>
		</author>
		<author initials="S." surname="Lassen" fullname="Soren Lassen">
			<organization>Google, Inc. </organization>
			<address>
				<email>soren@google.com</email>
			</address>
		</author>
		<author initials="S." surname="Thorogood" fullname="Sam Thorogood">
			<organization>Google, Inc. </organization>
			<address>
				<email>thorogood@google.com</email>
			</address>
		</author>
		<date year="2009" month="July"/>
		<note title="Document Status">
			<t>This document represents work in progress. It omits details that we are unable to capture at this 
			point and we expect parts of the protocol to change. Please also note that while we revise the 
			protocol and white papers, some transient inconsistencies will occur.
		</t>
		</note>
	</front>
	<middle>
		<section title="Introduction" anchor="intro">
			<section title="Overview" anchor="intro-overview">
				<t>The Google Wave Federation Protocol Over XMPP is an open extension to the <xref target="RFC3920">XMPP core</xref>
				 protocol allowing near real-time communication of wave updates between two wave servers.</t>
			</section>
			<section title="Terminology" anchor="intro-terms">
				<t>The capitalized key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="TERMS">BCP 14, RFC 2119</xref>.</t>
			</section>
		</section>
		<section title="Architectural Overview" anchor="arch">
			<t>Google Wave is a communication and collaboration platform based on hosted
        conversations, called waves. A wave consists of XML documents
        and supports concurrent modifications and low-latency updates between participants on the wave.</t>
			<section title="Wave Providers" anchor="providers">
				<t>The wave federation protocol enables everyone to become a wave
          provider and share waves with others. For instance, an organization
          can operate as a wave provider for its members, an individual can run
          a wave server as a wave provider for a single user or family members,
          and an Internet service provider can run a wave service as another
          Internet service for its users as a supplement to email, IM, ftp,
          etc.</t>
				<t>A wave provider is identified by its Internet domain name(s).</t>
				<t>Wave users have wave addresses which consist of a user name and a
          wave provider domain in the same form as an email address, namely
          &lt;username&gt;@&lt;domain&gt;. Wave addresses can also refer to groups, robots,
              gateways, and other services. A group address refers to a
              collection of wave addresses, much like an email mailing list. A
              robot can be a translation robot or a chess game robot. A gateway
              translates between waves and other communication and sharing
              protocols such as email and IM.  In the remainder we ignore
              addressees that are services, including robots and gateways - they
              are treated largely the same as users with respect to
              federation.</t>
				<t>Wave users access all waves through their wave provider. If a
              wave has participants from different wave providers, their wave
              providers all maintain a copy of the wave and serve it to their
              users on the wave. The wave providers share updates to the wave
              with each other using the wave federation protocol which we
              describe below.  For any given wave user, it is the responsibility
              of the wave provider for the user's domain to authenticate the
              user (using cookies and passwords, etc) and perform local access
              control.</t>
			</section><!--<t>More information on wave[let] and document identifiers, may be found in Alex North's identifier document. </t> -->
			<section title="Wavelets" anchor="wavelets">
				<t>A wave consists of a set of wavelets. When a user has access to a
          wavelet, that user is called a participant of that wavelet. Each
          wavelet has a list of participants, and a set of documents that make
          up its contents. Different wavelets of a wave can have different lists
          of participants. Copies of a wavelet are shared across all of the wave
          providers that have at least one participant in that wavelet. Amongst
          these wave providers, there is a designated wave provider that has the
          definitive copy of that wavelet. We say that this particular provider
          is hosting that wavelet.</t>
				<t>When a user opens a wave, a view of the wave is retrieved, namely the
          set of wavelets in the wave that the user is a participant of
          (directly, or indirectly via group membership). In general, different
          users have different wave views for a given wave. For example,
          per-user data for a user in a wave, such as the user's read/unread
          state for the wave, is stored in a user-data wavelet in the wave with
          the user as the only participant. The user-data wavelet only appears
          in this user's wave view. Another example is a private reply within a
          wave, which is represented as a wavelet with a restricted participant
          list. The private reply wavelet is only in the wave views of the
          restricted list of users.</t>
				<t>A wave is identified by a globally unique wave id, which is a pair of
          a domain name and an id string. The domain names the wave provider
          where the wave originated.</t>
				<t>A wavelet has a wavelet id which is unique within its wave. Like a
          wave id, a wavelet id is a pair of a domain name and an id string. The
          domain name in the wavelet id plays a special role: It names the wave
          provider that hosts the wavelet. A wavelet is hosted by the wave
          provider of the participant who creates the wavelet. The wave provider who hosts
          a wavelet is responsible both for operational transformation and application of 
          wavelet operations to the wavelet and for sharing the applied operations with 
          the wave providers of all the wavelet participants</t>
				<t>Wavelets in the same wave can be hosted by different wave providers.
          For example, a user-data wavelet is always hosted by the user's wave
          provider, regardless of where the rest of the wave is hosted. Indeed,
          user-data is not federated, i.e., not shared with other wave
          providers. Another example is a private reply wavelet. A particularly
          simple instance of this is when all the participants of the private
          reply are from the same wave provider. Then this wave provider will
          not share the private reply wavelet with other wave providers,
          regardless of where the other wavelets in the wave are hosted.</t>
			</section>
			<section title="Documents" anchor="documents">
				<t>Each wavelet is a container for any number of
          documents. Each document has an id that is unique within its containing
          wavelet. It is composed of an XML document and a set of
          annotations. Annotations are key-value pairs that span arbitrary ranges of the XML document
          and are independent of the XML document structure. They are used to
          represent text formatting, spelling suggestions and hyper-links.</t>
				<t>Some documents represent rich-text messages in the wavelet. 
				These are known as "blips". The blips in a wave form a threaded 
				conversation. Others represent data, for example tags, and are 
				not displayed to the user as part of the threaded conversation 
				structure in the wave. For detailed information on the 
				structure of documents, please refer to the 
				<eref target="http://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/operational-transform">Google
            Wave Operational Transformation</eref> white paper.</t>
			</section>
			<section title="Operations" anchor="operations">
				<t>Operations are mutations on wavelets. The state of a wavelet is
          entirely defined by a sequence of operations on that wavelet.</t>
				<t>Clients and servers exchange operations in order to communicate
          modifications to a wavelet. Operations propagate through the system to
          all clients and servers interested in that wavelet. They each apply
          the operation to their own copy of the wavelet. The use of 
          <eref target="http://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/operational-transform">
          operational transformation (OT)</eref> guarantees all copies of the wavelet
          will eventually converge to the same state. In order for the
          guarantees made by OT to hold, all communication participants 
          must use the same operational transformation and composition algorithms
          (i.e. all OT implementations must be functionally equivalent).</t>
			</section>
			<section title="Wave Service Architecture" anchor="architecture">
				<t>A wave provider operates a wave service on one or more networked
          servers. The central pieces of the wave service is the wave store,
          which stores wavelet operations, and the wave server, which resolves
          wavelet operations by operational transformation and writes and reads
          wavelet operations to and from the wave store. Typically, the wave
          service serves waves to users of the wave provider which connect to
          the wave service frontend (see <eref target="http://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/internal-client-server-protocol">Google Wave Data Model and
          Client-Server Protocol</eref>), and we shall assume this in the following
          description of the wave service architecture. More importantly, for
          the purpose of federation, the wave service shares waves with
          participants from other providers by communicating with these wave
          provider's servers.</t>
				<t>For a given wave provider, its wave server serves wave views to local
          participants, i.e., participants from its domain. 
          This wave server stores the state of all wavelets that it knows about.
          Some are hosted by the wave server itself.  These are "local wavelets" relative to this wave server.
          Others are copies of wavelets hosted by other wave providers.  These are "remote".
          A wave view can contain both types of wavelet
          simultaneously.</t>
				<t>At a particular wave provider, local wavelets are those created at
          that provider, namely by users who belong to the wavelet provider. The
          wave server is responsible for processing the wavelet operations
          submitted to the wavelet by local participants and by remote
          participants from other wave providers. The wave server performs
          concurrency control by ordering the submitted wavelet operations
          relative to each other using operational transformation. It also
          validates the operations before applying them to a local wavelet.</t>
				<t>Remote wavelets are hosted by other wave providers. The wave server
          maintains cached copies locally and updates them with wavelet
          operations that it gets from the hosting wave providers. When a local
          participant submits a wavelet operation to a remote wavelet, the wave
          server forwards the operation to the wave server of the hosting
          provider. When the transformed and applied operation is echoed back,
          it is applied to the cached copy. Read access to local participants is
          done from the cached copy without a round trip to the hosting wave
          provider.</t>
				<t>Local and remote wavelets are all stored in the wave server's
          persistent wave store.</t>
				<t>We say that a wave provider is "upstream" relative to its local
          wavelets and that it is "downstream" relative to its remote
          wavelets.</t>
				<section title="Federation Host and Federation Remote" anchor="host-and-remote">
					<t>The wave service uses two components for peering with other wave providers, a
          "federation host" and a "federation remote". (In an earlier revision of this draft specification
          these components were called "federation gateway" and "federation proxy", respectively).</t>
					<t>The federation host communicates local wavelet operations, i.e.,
          operations on local wavelets:
          <list style="symbols">
							<t>It pushes new wavelet operations that are applied to a local
              wavelet to the wave providers of any remote participants.</t>
							<t>It satisfies requests for old wavelet operations.</t>
							<t>It processes wavelet operations submission requests.</t>
						</list>
					</t>
					<t>The federation remote communicates remote wavelet operations and is 
          the component of a wave provider that communicates with the federation 
          host of upstream wave providers:
          <list style="symbols">
							<t>It receives new wavelet operations pushed to it from the wave
              providers that host the wavelets.</t>
							<t>It requests old wavelet operations from the hosting wave
              providers.</t>
							<t>It submits wavelet operations to the hosting wave providers.</t>
						</list>
					</t>
					<t>An upstream wave provider's federation host connects to a
          downstream wave provider's federation remote to push wavelet operations
          that are hosted by the upstream wave provider.</t>
					<t>The federation protocol has the following mechanisms to make
          operation delivery from host to remote reliable. The federation
          host maintains (in persistent storage) a queue of outgoing
          operations for each remote domain. Operations are queued until their
          receipt is acknowledged by the receiving federation remote. The
          federation host will continually attempt to establish a connection
          and reconnect after any connection failures (retrying with an
          exponential backoff). When a connection is established, the federation
          host will send queued operations. The receiving federation
          remote sends acknowledgements back to the sending federation host 
          and whenever an acknowledgement is received, the sender
          dequeues the acknowledged operations.</t>
				</section>
			</section>
		</section>
		<section title="Protocol Specification">
			<section title="Connection Initiation and Lifetime">
				<t>As an XMPP extension, this protocol expects a bidirectional stream to
				 be established according to the XMPP core specification.</t>
                               <t>The connection MUST be secured using the TLS feature of XMPP.
                                 It is RECOMMENDED that communication is encrypted (namely by using a non-identity TLS cipher).</t>
                               <t>
                                 All communication except wavelet updates are
                                 sent via <xref target="XEP0060">PubSub</xref> events. Wavelet updates are sent using Message stanzas.
                               </t>
			</section>
			<section title="Cryptographic Certificates and Signatures" anchor="security-note">
				<t>In the section below there are references to cryptographic signatures and certificates used to generate them.</t>
				<t>The paper by Kissner and Laurie, 
	            <eref target="https://sites.google.com/a/waveprotocol.org/wave-protocol/whitepapers/wave-protocol-verification">General Verifiable Federation</eref>
	            gives a detailed explanation of how we expect to make all changes to wavelets attributable to their originating servers
	            and render the federation protocol immune to a number of attacks. The techniques described in the paper have not yet been fully
                    implemented or incorporated into this protocol specification, however certificates are exchanged using the get signer and post 
                    signer XMPP messages.
	            </t>
			</section>
			<section title="Stanzas" anchor="iq-stanzas">
				<t>The federation protocol involves two parties: a wave federation host and wave
        federation remote as described <xref target="host-and-remote">above</xref>. The
        top level stanzas are divided into two types: those that are part of the "update stanzas", and those part of the "service stanzas".
        The <xref target="iq-elements-update-stream">update stanzas</xref> are initiated by a federation host to a federation remote and carry 
        <xref target="elements-update">&lt;update/&gt;</xref>s from the host to the remote. 
        The <xref target="iq-elements-service-stream">service stanzas</xref> are initiated by the federation remote to the federation host and
        carry <xref target="elements-submit-request">&lt;submit-request/&gt;</xref>s and 
        <xref target="elements-submit-response">&lt;submit-response/&gt;</xref>s, 
        <xref target="elements-history-request">&lt;history-request/&gt;</xref>s and 
        <xref target="elements-history-response">&lt;history-response/&gt;</xref>s,

<!--
        <xref target="signer-get-request">   &lt;signer-get-request/&gt;  </xref>s and 
        <xref target="signer-get-response">  &lt;signer-get-response/&gt; </xref>s,

        <xref target="signer-post-request">  &lt;signer-post-request/&gt; </xref>s and  
        <xref target="signer-post-response"> &lt;signer-post-response/&gt;</xref>s.
-->
        &lt;signer-get-request/&gt;s and 
        &lt;signer-get-response/&gt;s,

        &lt;signer-post-request/&gt;s and  
        &lt;signer-post-response/&gt;s.
</t>
				<section title="Commonly used attributes" anchor="attributes">
					<t>These stanzas commonly contain the following attributes:</t>
                                        <section title="wavelet-name" anchor="elements-wavelet-name">
						<t>The 'wavelet-name' attribute is an encoded form of the following components:</t>
						<t>
							<list style="symbols">
								<t>A "wave id" specifies the domain of the wave provider that originally started the wave, plus
								an identifier unique within that domain.</t>
								<t>A "wavelet id" specifies the domain of the wave provider that hosts the wavelet, plus
								 a unique identifier which is unique within all wavelets with that domain, within the wave.</t>
							</list>
						</t>
						<t>These components are encoded into a single string in the format of a netpath of an URI. The wavelet id domain 
							  is used as the host part (since this is 
   							where the wavelet is hosted). The wave id is used as the first path element, which contains the wave id domain
   							if it does not match the wavelet id domain, in this case it is prepended to a unique
   							identifier with a '$' delimiter. The unique identifier in the wavelet id is the final path element. 
   							URI generic delimiter 
   							characters (:/?#[]@) appearing in the id parts must be percent-escaped.</t>
						<t>For example, a 'wavelet-name' might be "initech-corp.com/acmewave.com$w+4Kl2/conv+3sG7", 
						where the wavelet id has domain "initech-corp.com" and unique identifier "conv+3sG7", 
						and the wave id has domain "acmewave.com" and unique identifier "w+4Kl2".</t>
						<t>If the wavelet was hosted at "initech-corp.com" and the wave had also been started on that domain, 
						the 'wavelet-name' would be "initech-corp.com/w+4Kl2/conv+3sG7".</t>
					</section>
				</section>
				<section title="Commonly used elements" anchor="elements">
					<section title="hashed-version" anchor="elements-history-hash">
						<t>A &lt;hashed-version/&gt; element contains the version and history hash pair of a wavelet. 
							<list style="symbols">
								<t>'version' -- REQUIRED attribute which contains the version of the wavelet.</t>
								<t>'history-hash' -- REQUIRED attribute which is the value of the rolling history hash at the given version.</t>
							</list>
						</t>
					</section>
					<section title="commit-notice" anchor="elements-commit-notice">
						<t>The &lt;commit-notice/&gt; element is a variant of the &lt;hashed-version/&gt; element. 
						It is used to indicate that the wave server has committed deltas up to this point.
							<list style="symbols">
								<t>'version' -- REQUIRED attribute which contains the version of the wavelet.</t>
							</list>
						</t>
					</section>
					<section title="delta" anchor="elements-delta">
						<t>The &lt;delta/&gt; element contains a sequence of one or more operations grouped for communication to and between wave servers:
							<list style="symbols">
								<t>'wavelet-name' -- REQUIRED <xref target="elements-wavelet-name">wavelet-name</xref>.</t>
								<t>&lt;operation/&gt; -- The operation is carried as the text of the &lt;delta&gt; element 
                                                                  as a Base64 encoded protocol buffer.</t>
							</list>
						</t>
					</section>
					<section title="applied-delta" anchor="elements-applied-delta">
						<t>The &lt;applied-delta/&gt; element contains a delta which has been successfully applied to a wavelet by a wave server, along with 
						supplementary information about the result of the application.
							<list style="symbols">

								<t>&lt;operation/&gt; -- The operation is carried as the text of the &lt;applied-delta&gt; element 
                                                                  as a Base64 encoded protocol buffer.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Update Stanzas" anchor="iq-elements-update-stream">
					<t>The wavelet-update operation is sent as a Message stanza.</t>
					<section title="wavelet-update" anchor="elements-update">
						<t>The  &lt;wavelet-update/&gt; element is used within a Message stanza. 
						It is used to push new wavelet 
						operations applied to a local wavelet to the wave providers of any remote participants.
                                              </t>
						<t>When the requester is resending updates after reconnecting a XMPP stream, 
						the &lt;wavelet-update/&gt; MAY omit the &lt;applied-delta/&gt; elements but MUST resend the 
						&lt;commit-notice/&gt; elements. In this case the &lt;commit-notice/&gt; informs the receiver of the existence 
						of updates, and it is
						up to the receiver to request these using a &lt;history-request/&gt; on a service stream.</t>
					</section>
					<section title="Successful update and response example">
						<t>An example of otherwave.com's federation host pushing data to a federation remote:</t>
						<figure>
							<preamble>Step 1: otherwave.com's federation host sends an update to the federation remote:</preamble>
							<artwork><![CDATA[
<message type="normal" 
  from="wave.initech-corp.com" 
  id="1-1" to="wave.acmewave.com">
  <request xmlns="urn:xmpp:receipts"/>
  <event xmlns="http://jabber.org/protocol/pubsub#event">
    <items>
      <item>
        <wavelet-update 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver" 
          wavelet-name="acmewave.com/initech-corp.com!a/b">
          <applied-delta><![CDATA[CiI...MwE] ]></applied-delta>
        </wavelet-update>
      </item>
    </items>
  </event>
</message>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: The federation remote acknowledges the update, indicating success.</preamble>
							<artwork><![CDATA[
<message id="1-1"
  from="wave.acmewave.com"
  to="wave.initech-corp.com">
  <received
    xmlns="urn:xmpp:receipts"/>
</message>
]]></artwork>
						</figure>
					</section>
				</section>
				<section title="Service Stanzas" anchor="iq-elements-service-stream">
					<t>The service stanzas are for the submission of operations and wavelet history retrieval.</t>
					<section title="History Request" anchor="elements-history-request">
						<t>The &lt;delta-history/&gt; element is used within a <xref target="XEP0060">PubSub</xref> event. 
                                                  It is sent by a federation 
						remote to request wavelet operations from the hosting wave
            providers. The response by the host provider's federation host will contain the operations
            for the requested version range.
            													<list style="symbols">
								<t>'wavelet-name' -- REQUIRED attribute.</t>
								<t>'start-version' -- REQUIRED attribute with version number (inclusive) from which to retrieve the wavelet's history. (Note that 
the start version MUST fall on a delta boundary).</t>         

								<t>'start-version-hash' -- REQUIRED attribute with the hash for the associated start version.</t>
								<t>'end-version' -- OPTIONAL attribute with ending version number (exclusive) up to which to retrieve the wavelet's history. (Note that 
the end version MUST fall on a delta boundary).</t>
								<t>'end-version-hash' -- REQUIRED attribute with the hash for the associated end version.</t>
								<t>'response-length-limit' -- OPTIONAL attribute containing advice from the requester about the preferred
  response limit, measured as the aggregate number of characters in the XML
  serialization of the applied deltas in the response.  The responder is
  advised but not required to respect the limit.  Moreover, the responder
  may operate with a lower limit of its own and send back a smaller message
  than requested.  When the responder exercises either its own or the
  requester's limit, it will return only a prefix of the requested wavelet deltas.
  Unless the version range is empty, the responder will always return a minimum of
  one wavelet delta (the first) even if its length exceeds the responders or
  requester's limits.</t>
							</list>
						</t>
					</section>
					<section title="History Response" anchor="elements-history-response">
						<t>The response to a History Request contains: 
		  					<list style="symbols">
								<t>&lt;history-truncated&gt; -- OPTIONAL attribute indicating that the returned deltas were truncated at the given 
version number (exclusive).  Truncation will occur if the 
<xref target="elements-history-request">&lt;delta-history/&gt;</xref> specified a 'response-length-limit' attribute or the responder imposed its own limit.</t>
								<t>&lt;applied-delta/&gt; -- the update contains ZERO OR MORE &lt;applied-delta/&gt; elements, starting from the requested version up to 
the requested end version (exclusive), or until the latest version if the request did not contain the end version, or up to the version
indicated in 'version-truncated-at'.</t>
								<t>&lt;commit-notice/&gt; -- OPTIONAL element indicating that some range of the returned deltas has not been
								 committed to persistent storage by the hosting wave server. The &lt;commit-notice/&gt; indicates up to which 
								 version the server has committed.</t>
							</list>
						</t>
					</section>
					<section title="Successful history request / history response example">
						<figure>
							<preamble>Step 1: A federation remote makes a
							<xref target="elements-history-request">history-request</xref> to the acmewave.com federation host:</preamble>
							<artwork><![CDATA[
<iq type="get" id="1-1" from="wave.initech-corp.com" to="wave.acmewave.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <items node="wavelet">
      <delta-history 
        xmlns="http://waveprotocol.org/protocol/0.2/waveserver"
        start-version="12" 
        start-version-hash="" 
        end-version="2345" 
        end-version-hash=""
        response-length-limit="300000"
        wavelet-name="acmewave.com/initech-corp.com!a/b"/> 
    </items>
  </pubsub>
</iq>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: acmewave.com's federation host returns the requested history.</preamble>
							<artwork><![CDATA[
<iq type="result" id="1-1" from="wave.acmewave.com" to="wave.initech-corp.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <items>
      <item>
        <applied-delta 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver">
            <![CDATA[CiI...MwE] ]>
        </applied-delta>
      </item>
      <item>
        <commit-notice 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver" 
          version="2344"/>
      </item>
      <item>
        <history-truncated 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver" 
          version="2300"/>
      </item>
    </items>
  </pubsub>
</iq>
]]></artwork>
						</figure>
					</section>
					<section title="Submit Request" anchor="elements-submit-request">
						<t>The &lt;submit-request/&gt; element is used within a <xref target="XEP0060">PubSub</xref> event.
						The federation remote submits wavelet operations to the hosting wave provider.
            A &lt;submit-response/&gt; will be returned.
	            <list style="symbols">
								<t>&lt;delta/&gt; -- REQUIRED delta element to be submitted.</t>
							</list>
						</t>
					</section>
					<section title="submit-response" anchor="elements-submit-response">
						<t>A &lt;submit-response/&gt;  element is used within a <xref target="XEP0060">PubSub</xref> response.
                                                  It is returned by a federation host 
						after the hosting wave server has processed the submitted delta.
						<list style="symbols">
								<t>'operations-applied' -- REQUIRED attribute with the number of operations applied by the wave server after transforming the submitted delta.</t>
								<t>'application-timestamp' -- REQUIRED timestamp (milliseconds since epoch) attribute recording the time of delta application.</t>
								<t>'error-message' -- OPTIONAL string attribute containing an error message if the an error occurred while applying the delta. 
								Note it's possible to partially apply a delta, in which case the error message will be present.</t>
								<t>&lt;hashed-version/&gt; -- REQUIRED element with the version and history hash of the wavelet after the submitted delta was applied.</t>
							</list>
						</t>
					</section>
					<section title="Successful submit request / submit response example">
						<figure>
							<preamble>Step 1: The federation remote makes an submit request to the initech-corp.com federation host:</preamble>
							<artwork><![CDATA[

<iq type="set" id="1-1" from="wave.initech-corp.com" to="wave.acmewave.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <publish node="wavelet">
      <item>
        <submit-request 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver">
          <delta wavelet-name="acmewave.com/initech-corp.com!a/b">
            <![CDATA[CiA...NvbQ==] ]>
          </delta>
        </submit-request>
      </item>
    </publish>
  </pubsub>
</iq>
]]></artwork>
						</figure>
						<figure>
							<preamble>Step 2: The initech-corp.com federation host returns a response to the submit request. Note that this example
							shows the case where a different party submitted a delta at version 100 with 3 operations before this submit-request was received.
							The requester's submitted delta was thus transformed before it was applied, and as a result the version number at which it was applied was 103.</preamble>
							<artwork><![CDATA[
<iq type="result" id="1-1" from="wave.acmewave.com" to="wave.initech-corp.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <publish>
      <item>
        <submit-response 
          xmlns="http://waveprotocol.org/protocol/0.2/waveserver" 
          application-timestamp="1234567890" 
          operations-applied="2">
          <hashed-version 
            history-hash="" 
            version="1234"/>
        </submit-response>
      </item>
    </publish>
  </pubsub>
</iq>
]]></artwork>
						</figure>
					</section>
				</section>
			</section>
		</section>
		<section title="Wavelet Update" anchor="wavelet-ops">
			<t>Wavelet update operations mutate wavelets.  The actual operation is a signed protocol buffer
                          that is included in the applied-delta element Base64 encoded text. The wavelet update 
                          MAY contain multple applied-delta's and an optional commit-notice. The wavelet update
                          response is an XMPP receipt of the form specified in XEP-0184.
                        </t>
                        <t> Here is an example exchange:</t>
                        <figure>
				<artwork><![CDATA[
<message type="normal" from="wave.initech-corp.com" id="1-1" to="wave.acmewave.com">
  <request xmlns="urn:xmpp:receipts"/>
  <event xmlns="http://jabber.org/protocol/pubsub#event">
    <items>
      <item>
        <wavelet-update xmlns="http://waveprotocol.org/protocol/0.2/waveserver" wavelet-name="acmewave.com/initech-corp.com!a/b">
          <applied-delta><![CDATA[CiIKIAoFCNIJEgASF2ZvenppZUBpbml0ZWNoLWNvcnAuY29tEgUI0gkSABgCINKF2MwE] ]></applied-delta>
        </wavelet-update>
      </item>
    </items>
  </event>
</message>
]]></artwork>
						</figure>

                        <figure>
				<artwork><![CDATA[
<message id="1-1" from="wave.acmewave.com" to="wave.initech-corp.com">
  <received xmlns="urn:xmpp:receipts"/>
</message>
]]></artwork>
						</figure>

    </section>
    <section title="Get Signer" anchor="get-signer">
      <t>A remote wave server issues a signer-request to request
        certificates for wavelets where the signer of the wavelet is currently
        unknown. The request is sent to the wave server that hosts the wavelet.
        The provided history-hash identifies the delta for which the 
        certificate is being requested.
      </t>
                        <t> Here is an example exchange:</t>
                        <figure>
				<artwork><![CDATA[
<iq type="get" id="1-1" from="wave.initech-corp.com" to="wave.acmewave.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <items node="signer">
      <signer-request xmlns="http://waveprotocol.org/protocol/0.2/waveserver"
        history-hash="somehash" version="1234"
        wavelet-name="acmewave.com/initech-corp.com!a/b"/> </items>
  </pubsub>
</iq>
]]></artwork>
						</figure>

        <t>The hosting wave server replies with a chain of certificates
          sent Base64 encoded in the certificate elements. Each certificate element
          represents a single certificate. The order of the certificate elements
          goes from the first which is the closest certificate, to the last
          certificate which is the root for the certificate chain. 
          More details on signing are still to be added to this document.
        </t>

                        <figure>
				<artwork><![CDATA[
<iq type="result" id="1-1" from="wave.acmewave.com" to="wave.initech-corp.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <items>
      <signature xmlns="http://waveprotocol.org/protocol/0.2/waveserver"
        domain="initech-corp.com" algorithm="SHA256">
        <certificate><![CDATA[Q0VS...VElPTg==] ]></certificate>
        <certificate><![CDATA[QkV...LRQ==] ]></certificate>
      </signature>
    </items>
  </pubsub>
</iq>
]]></artwork>
                                                </figure>

    </section>
    <section title="Post Signer" anchor="post-signer">
      <t>Before submitting a wavelet delta for the first time, a remote wave
        server will supply the certificate chain 
        that will allow the hosting wave server to authenticate the signed wave
        delta.
        More details on signing are still to be added to this document.
      </t>
                        <t> Here is an example exchange:</t>
                        <figure>
				<artwork><![CDATA[
<iq type="set" id="1-1" from="wave.initech-corp.com" to="wave.acmewave.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <publish node="signer">
      <item>
        <signature xmlns="http://waveprotocol.org/protocol/0.2/waveserver"
          domain="initech-corp.com" algorithm="SHA256">
          <certificate><![CDATA[Q0V...Tg==] ]></certificate>
          <certificate><![CDATA[QkV...RQ==] ]></certificate>
        </signature>
      </item>
    </publish>
  </pubsub>
</iq>

]]></artwork>
						</figure>
      <t>The hosting wave server acks the message.
      </t>

                        <figure>
				<artwork><![CDATA[
<iq type="set" id="1-1" from="wave.initech-corp.com" to="wave.acmewave.com">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
    <publish>
      <item node="signer">
        <signature-response xmlns="http://waveprotocol.org/protocol/0.2/waveserver" />
      </item>
    </publish>
  </pubsub>
</iq>
]]></artwork>
                                                </figure>



    </section>
    <section title="Documents">
          <t>A document is a sequence of items, where each item is a character,
            a start tag, or an end tag.  Each item has a key-value map of
            annotations.</t>
            
          <t>Characters are Unicode code points.  Certain control characters,
            special characters and noncharacters are not permitted.</t>
            
          <t>Start tags consist of a type and attributes.  The type is an XML
            name.  The attributes form a key-value map, where keys and values
            are strings.  Certain Unicode control characters, special characters
            and noncharacters are permitted neither in the type nor in attribute
            names or values.</t>

          <t>Each end tag terminates the rightmost unterminated start tag; the
            tag name is implicit.  The number of start tags in the document
            equals the number of end tags, and for every prefix of the document,
            the number of start tags equals or exceeds the number of end tags.
            Thus, start and end tags nest properly, and there are no
            self-closing tags.</t>

          <t>Annotation keys and values are strings.  Certain Unicode control
            characters, special characters and noncharacters are not permitted.
            If the map has no entry for a given key, we sometimes say that the
            value for that key is null.  While each item conceptually has its
            own annotation map, implementations may find it more efficient to
            have just one annotation map for each consecutive run of items with
            the same annotations.</t>

          <t>Note that a naive serialization of the document without annotations
            into a string is not formally an XML document because it can have
            multiple elements and characters at the top level, while XML
            requires a single root element.  How to interpret the document as
            XML is up to the application; options include making sure at the
            application level that the entire document contents are inside a
            single element even if the protocol does not enforce this; ignoring
            all content other than the first element; or wrapping the entire
            document in an implicit root element whose type and attributes are
            not represented inside the document.</t>
         <section title="Document operations">
           <t>A document operation is a set of instructions that specify how to
             process an input document, reading its sequence of items from left
             to right, to generate an output document.  For the purpose of this
             specification, the operation does not modify the input document,
             although implementations that perform destructive updates are
             possible.</t>
           <t>Document operations are invertible; for any document operation op
             that turns an input document A into an output document B, an
             inverse operation that turns B into A can always be derived from op
             without knowledge of A or B.</t>
           <t>A document operation consists of a sequence of document operation
             components that are executed in order.  During this process, two
             pieces of state need to be maintained in addition to the document
             being processed:
             <list style="symbols">
               <t>the current location ('cursor') in the input document, either
                 to the left of the first item, between two items, or to the
                 right of the last item of the input document, and</t>
               <t>the current annotations update, which is a map of annotation
                 keys to pairs (old-value, new-value), where old-value and
                 new-value are either null or an annotation value.</t>
             </list>
             Initially, the cursor is to the left of the first item, and the
             annotations update is empty.</t>
           <t>
             After the final component, the annotations update must be empty,
             and the cursor must be to the right of the last item in the input
             document.
           </t>
           </section>
           <section title="Document operation components">
           <t>Document operation components can be divided into four classes:
             <list style="symbols">
               <t>update components (retain, replaceAttributes,
                 updateAttributes) move the cursor over a consecutive range of
                 input items and generate corresponding but potentially modified
                 items in the output document;</t>
               <t>insertion components (characters, elementStart, elementEnd)
                 generate items in the output document without moving the
                 cursor;</t>
               <t>deletion components (deleteCharacters, deleteElementStart,
                 deleteElementEnd) move the cursor over a consecutive range
                 of input items without generating any output;</t>
               <t>annotation boundaries (annotationBoundary) change the current
                 annotations update but do not directly affect the document or
                 the cursor.</t>
             </list>
           </t>
           <t>The different component classes have the following interaction
             with annotations:
             <list style="symbols">
               <t>For update components, the old values in the annotations
                 update match the annotation values of each item in the input
                 document that the component processes.  The generated items in
                 the output document will have the same annotations as the
                 corresponding input items, except for the annotation keys in
                 the annotations update; for those keys, the generated items
                 will have the new values.
               </t>
               <t>
                 For insertion components, the old values in the annotations
                 update match the annotations of the item to the left of the
                 cursor.  The inserted items are annotated with the new values
                 from the annotations update in addition to any annotations on
                 the item to the left of the cursor with keys that are not part
                 of the annotations update.  <vspace/> If the cursor is at the
                 beginning of the document, the old values in the annotations
                 update are null, and the inserted items are annotated with the
                 new values from the annotations update.
               </t>
               <t>For deletion components, the old values in the annotations
                 update match the annotations of each item in the input document
                 processed by the component, and the new values match the
                 annotations of the rightmost item generated so far.  All
                 annotation keys that have different values in the processed
                 item and the rightmost item generated so far are present in the
                 annotations update.  <vspace/> If no items have been generated
                 so far, the new values are null, and all annotation keys of the
                 deleted items must be present in the annotations update.
               </t>
             </list>
           </t>
             <t>
             <list style="hanging">
                <t hangText="retain(itemCount)">
                  The cursor moves over the next itemCount items, and they are
                  copied to the output document, with annotations as described
                  above.  The argument itemCount is a positive integer.</t>
                <t hangText="replaceAttributes(oldAttributes, newAttributes)">
                  The cursor moves over the next item, which must be a start tag
                  with the attributes oldAttributes.  A start tag with the same
                  type but the attributes newAttributes is generated in the
                  output.  Its annotations are as described above.
                  <vspace/>
                  The arguments oldAttributes and newAttributes are key-value
                  maps.</t>
                <t hangText="updateAttributes(attributesUpdate)">
                  The cursor moves over the next item, which must be a start
                  tag.  A start tag with the same type is generated in the
                  output, with annotations as described above.  <vspace/> The
                  argument attributesUpdate is a map of attribute names to pairs
                  (oldValue, newValue), where oldValue and newValue are either
                  null or an attribute value.  The oldValues match the
                  attributes of the start tag in the input document; an oldValue
                  of null means no such attribute is present.  The generated
                  start tag has the new values for the attributes in
                  attributesUpdate.  Attributes in the input whose names are not
                  listed are transferred to the output unchanged.
                </t>
                <t hangText="characters(characters)">
                  The specified characters are inserted into the output
                  document, with annotations as described above.
                </t>
                <t hangText="elementStart(type, attributes)">
                  An element start with type type and attributes attributes is
                  inserted into the output document, with annotations as
                  described above.  <vspace/> This component must be terminated
                  with an elementEnd.  Between an elementStart and its
                  corresponding elementEnd, only insertion components are
                  permitted.
                </t>
                <t hangText="elementEnd">
                  An element end is inserted into the output document, with
                  annotations as described above.  <vspace/>This component
                  terminates the most recent unterminated elementStart.  It must
                  not occur without a corresponding elementStart.
                </t>
                <t hangText="deleteCharacters(characters)">
                  This component moves the cursor over the specified characters
                  in the input document without generating any output.  The
                  characters must match the actual characters in the input
                  document, and the current annotations update must match as
                  described above.
                </t>
                <t hangText="deleteElementStart(type, attributes)">
                  This component moves the cursor over the specified element
                  start in the input document without generating any output.
                  There must be an element start to the right of the cursor, and
                  its type and attributes must match the arguments.  The current
                  annotations update must match as described
                  above. <vspace/>This component must be terminated with a
                  deleteElementEnd.  Between a deleteElementStart and its
                  corresponding deleteElementEnd, only deletion components are
                  permitted.
                </t>
                <t hangText="deleteElementEnd">
                  This component moves the cursor over an element end in the
                  input document without generating any output.  There must be
                  an element end to the right of the cursor.  The current
                  annotations update must match as described
                  above. <vspace/>This component terminates the most recent
                  unterminated deleteElementStart.  It must not occur without a
                  corresponding deleteElementStart.
                </t>
                <t hangText="annotation-boundary(ends, changes)">
                  This component modifies the current annotations update.  Ends
                  is a set of annotation keys; these keys are removed from the
                  annotations update.  Changes is a map of annotation keys to
                  pairs (oldValue, newValue), where oldValue and newValue are
                  either null or an annotation value; these entries are added to
                  the annotations update, or replace entries in the annotations
                  update that have the same key.  The keys in ends and changes
                  must be disjoint.

                  <vspace/>An operation must not contain two consecutive
                  annotationBoundary components.  Ends must only contain keys
                  that are part of the current annotations update.
                </t>
             </list>
             </t>
           </section>

</section>
	</middle>
	<back>
		<references title="References">
                  <reference anchor="XEP0060">
				<front>
					<title abbrev="PubSub">XMPP
                                          Publish Suscribe</title>
					<author fullname="Peter Millard">
						<organization></organization>
					</author>
					<author fullname="Peter Saint-Andre">
						<organization></organization>
					</author>
					<author fullname="Ralph Meijer">
						<organization></organization>
					</author>
					<date month="September" year="2008"/>
					<area>XMPP</area>
					<keyword>keyword</keyword>
					<abstract>
                                          <t>
                                            This specification defines an XMPP protocol extension for generic
                                            publish-subscribe functionality. The protocol enables XMPP entities to create
                                            nodes (topics) at a pubsub service and publish information at those nodes; an
                                            event notification (with or without payload) is then broadcasted to all
                                            entities that have subscribed to the node. Pubsub therefore adheres to the
                                            classic Observer design pattern and can serve as the foundation for a wide
                                            variety of applications, including news feeds, content syndication, rich
                                            presence, geolocation, workflow systems, network management systems, and any
                                            other application that requires event notifications.  </t>
					</abstract>
				</front>
				<format type="HTML" target="http://xmpp.org/extensions/xep-0060.html"/>
			</reference>
			<reference anchor="TERMS">
				<front>
					<title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization>Harvard University</organization>
						<address>
							<postal>
								<street>1350 Mass.  Ave.</street>
								<street>Cambridge</street>
								<street>MA 02138</street>
							</postal>
							<phone>- +1 617 495 3864</phone>
							<email>sob@harvard.edu</email>
						</address>
					</author>
					<date month="March" year="1997"/>
					<area>General</area>
					<keyword>keyword</keyword>
					<abstract>
						<t>
					   In many standards track documents several words are used to signify
					   the requirements in the specification.  These words are often
					   capitalized.  This document defines these words as they should be
					   interpreted in IETF documents.  Authors who follow these guidelines
					   should incorporate this phrase near the beginning of their document:

							<list>
								<t>
								  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
								  NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
								  "OPTIONAL" in this document are to be interpreted as described in
								  RFC 2119.
								</t>
							</list>
						</t>
						<t>
						   Note that the force of these words is modified by the requirement
						   level of the document in which they are used.
						</t>
					</abstract>
				</front>
				<seriesInfo name="BCP" value="14"/>
				<seriesInfo name="RFC" value="2119"/>
				<format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
				<format type="HTML" octets="14486" target="http://xml.resource.org/public/rfc/html/rfc2119.html"/>
				<format type="XML" octets="5661" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"/>
			</reference>
			&rfc3920;
		</references>
		<section title="Protocol Schema">
			<t>The protocol schema, as RelaxNG compact:</t>
			<figure>
				<artwork>&rncschema;</artwork>
			</figure>
		</section>
		<section title="Protocol Buffers">
			<t>The protocol buffer definitions</t>
			<figure>
				<artwork>&waveproto;</artwork>
			</figure>
		</section>
	</back>
</rfc>
